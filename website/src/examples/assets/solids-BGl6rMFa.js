import{B as M,i as P,a as Y,j as q,k as J,e as K,v as w,g as N,F as Q,S as j,P as Z,l as O,m as R,n as S}from"./styles-CRQ6mFCx.js";import{g as $}from"./getParameters-DvaQSv0e.js";function U(n,d=!1){const f=n[0].index!==null,h=new Set(Object.keys(n[0].attributes)),p=new Set(Object.keys(n[0].morphAttributes)),c={},g={},l=n[0].morphTargetsRelative,i=new M;let a=0;for(let e=0;e<n.length;++e){const t=n[e];let s=0;if(f!==(t.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const r in t.attributes){if(!h.has(r))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+r+'" attribute exists among all geometries, or in none of them.'),null;c[r]===void 0&&(c[r]=[]),c[r].push(t.attributes[r]),s++}if(s!==h.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(l!==t.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const r in t.morphAttributes){if(!p.has(r))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;g[r]===void 0&&(g[r]=[]),g[r].push(t.morphAttributes[r])}if(d){let r;if(f)r=t.index.count;else if(t.attributes.position!==void 0)r=t.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;i.addGroup(a,r,e),a+=r}}if(f){let e=0;const t=[];for(let s=0;s<n.length;++s){const r=n[s].index;for(let o=0;o<r.count;++o)t.push(r.getX(o)+e);e+=n[s].attributes.position.count}i.setIndex(t)}for(const e in c){const t=k(c[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;i.setAttribute(e,t)}for(const e in g){const t=g[e][0].length;if(t===0)break;i.morphAttributes=i.morphAttributes||{},i.morphAttributes[e]=[];for(let s=0;s<t;++s){const r=[];for(let b=0;b<g[e].length;++b)r.push(g[e][b][s]);const o=k(r);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;i.morphAttributes[e].push(o)}}return i}function k(n){let d,f,h,p=-1,c=0;for(let a=0;a<n.length;++a){const e=n[a];if(d===void 0&&(d=e.array.constructor),d!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(f===void 0&&(f=e.itemSize),f!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(h===void 0&&(h=e.normalized),h!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(p===-1&&(p=e.gpuType),p!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;c+=e.count*f}const g=new d(c),l=new P(g,f,h);let i=0;for(let a=0;a<n.length;++a){const e=n[a];if(e.isInterleavedBufferAttribute){const t=i/f;for(let s=0,r=e.count;s<r;s++)for(let o=0;o<f;o++){const b=e.getComponent(s,o);l.setComponent(s+t,o,b)}}else g.set(e.array,i);i+=e.count*f}return p!==void 0&&(l.gpuType=p),l}const A={points:w.state([]),columns:w.state([]),slabs:w.state([])},B=[[0,0,4],[0,10,4],[18,10,4],[18,0,4],[0,0,4]],C=[[[0,0,0],[0,0,4]],[[0,10,0],[0,10,4]],[[18,10,0],[18,10,4]],[[18,0,0],[18,0,4]],[[6,0,0],[6,0,4]],[[6,10,0],[6,10,4]]],I={stories:{value:w.state(2),min:1,max:5,step:1}},V=new Y(new M,new q({color:16770764})),H=new J(new M,new K);H.frustumCulled=!1;H.material.depthTest=!1;const z=w.state([H]),ee=w.state([V]);w.derive(()=>{const n=[],d=[],f=[];for(let h=0;h<I.stories.value.val;h++){const p=[],c=[],l=4*h;for(let e=0;e<B.length;e++)p.push([B[e][0],B[e][1],B[e][2]+l]);const i=[],a=n.length;for(let e=0;e<p.length;e++)n.push(p[e]),i.push(e+a);d.push([i]);for(let e=0;e<C.length;e++){const t=C[e];c.push([[t[0][0],t[0][1],t[0][2]+l],[t[1][0],t[1][1],t[1][2]+l]])}for(let e=0;e<c.length;e++){const t=n.length;n.push(...c[e]),f.push([t,t+1])}}A.points.val=n,A.columns.val=f,A.slabs.val=d});w.derive(()=>{H.geometry=te(A.points.val,A.slabs.val,A.columns.val),V.geometry=re(A.points.val,A.slabs.val,A.columns.val),z.val=[...z.rawVal]});document.body.append($(I),N({objects3D:z,solids:ee}));function te(n,d,f){const h=new M,p=f.map(l=>[n[l[0]],n[l[1]]].flat()).flat(),c=d.map(l=>g(l[0]).map(i=>[...n[i[0]],...n[i[1]]]).flat()).flat();return h.setAttribute("position",new Q([...p,...c],3)),h;function g(l){if(l.length===2)return[l];const i=[];for(let a=0;a<l.length;a++)i.push([l[a],l[(a+1)%l.length]]);return i}}function re(n,d,f){const c=l(n,d),g=i(n,f);return U([c,g]);function l(a,e,t=.3){const s=[];for(let o=0;o<e.length;o++)for(let b=0;b<e[o].length;b++){const T=[];for(let y=0;y<e[o][b].length;y++){const x=e[o][b][y];T.push(a[x])}const u=r(T,.3/2),v=new j;new Z;for(let y=0;y<u.length;y++)y==0?v.moveTo(u[0][0],u[0][1]):v.lineTo(u[y][0],u[y][1]);const m=new O(v,{depth:t,bevelEnabled:!1});m.translate(0,0,u[0][2]-t/2),s.push(m)}return U(s);function r(o,b=0){const T=[],u=[];for(let m=0;m<o.length;m++)u.push(new R(o[m][0],o[m][1]));let v=new P(new Float32Array([b,0,0]),3);for(let m=0;m<u.length-1;m++){let y=new R().subVectors(u[m-1<0?u.length-1:m-1],u[m]),x=new R().subVectors(u[m+1==u.length?0:m+1],u[m]),F=(x.angle()-y.angle())*.5,L=x.angle()+Math.PI*.5,W=Math.tan(F-Math.PI*.5),_=new S().set(1,0,0,0,-W,1,0,0,0,0,1,0,0,0,0,1),E=L,X=new S().set(Math.cos(E),-Math.sin(E),0,0,Math.sin(E),Math.cos(E),0,0,0,0,1,0,0,0,0,1),D=new S().set(1,0,0,u[m].x,0,1,0,u[m].y,0,0,1,0,0,0,0,1),G=v.clone();G.needsUpdate=!0,G.applyMatrix4(_),G.applyMatrix4(X),G.applyMatrix4(D),T.push([G.getX(0),G.getY(0),o[m][2]])}return T}}function i(a,e){const t=[],s=new j;s.lineTo(0+.3,0),s.lineTo(0+.3,0+.3),s.lineTo(0,0+.3);for(let r=0;r<e.length;r++){const o=a[e[r][0]],T=a[e[r][1]][2]-o[2],u=new O(s,{depth:T,bevelEnabled:!1});u.translate(o[0]-.3/2,o[1]-.3/2,o[2]),t.push(u)}return U(t)}}
